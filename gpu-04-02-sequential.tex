The MCMC-aMMSB algorithm that is the subject of this paper was initially
implemented in Python~\cite{LiAW15}, as is common
with machine learning researchers and practitioners. It
relied on numpy~\cite{numpy} to perform the numerical computations without the
overhead associated with Python's interpreter. However, the algorithm also
depended on Python data structures such as sets, dictionaries and
lists, which are far less efficient.
This section describes how the Python implementation was
converted into an efficient sequential C++ application which serves as a
baseline for the parallel and distributed implementations.

First, the Python code base was ported into equivalent C++ code.
The program structure remained unchanged and the Python data structures were
simply substituted with their corresponding alternatives in C++.

The next step was to remove a number of inefficiencies in the C++
implementation. For example, one recurring idiom in the Python implementation
was an expression of the form $a^y b^{1-y}$, implemented with floating-point
exponentiation, where $y$ is a variable that can
only hold values of 0 or~1. Therefore, the expression is simply a choice
between $a$ for $y=1$ and $b$ for $y=0$. However, as the compiler cannot infer
the value of $y$, both expressions $a$ and $b$ were computed and their
resulting values were raised to the power $y$ and $1-y$ respectively.
We transformed such expressions into conditional expressions which
compute either the expression $a$ or $b$ and avoid exponentiation.
%
% Similarly, we transformed some expressions to a more efficient form.
% For example, we replaced expressions of the form $a^{0.5}\times{b}^{0.5}$
% with $sqrt(ab)$.
Other optimizations were loop strength
reduction and common subexpression lifting.

In summary, a multitude of localized optimizations were applied to achieve
an efficient sequential baseline version, which is 1000..1500 times faster
than the original Python code, see Section~\ref{sec-evaluation}.
All transformations were rigorously tested to ensure they do
not modify the behavior of the algorithm.

\begin{comment}
Further, we replaced calls to the system's random
functions with a custom implementation of the random generator
\textit{xorshift\_128}~\cite{Marsaglia:2003:XR}. This way, random calls no longer
involve system calls, so we can support easy and fast multi-threaded random
calls by providing each thread with its private, differently seeded, random
generator.
\end{comment}
